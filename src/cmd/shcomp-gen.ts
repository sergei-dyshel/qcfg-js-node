import { jsonDeepEqual } from "@sergei-dyshel/typescript";
import { mapAsync } from "@sergei-dyshel/typescript/array";
import { assertNotNull } from "@sergei-dyshel/typescript/error";
import { dedent } from "@sergei-dyshel/typescript/string";
import { ElementType } from "@sergei-dyshel/typescript/types";
import { zod } from "@sergei-dyshel/typescript/zod";
import { pathExists } from "fs-extra";
import { InstanceLogger, LogFormat, Logger, LogHandlerOptions, RootLogger } from "lib/logging";
import { pathJoin, which } from "lib/path";
import { run } from "lib/subprocess";
import { readFile, writeFile } from "node:fs/promises";
import { dirname } from "node:path";
import {
  allOclifCommands,
  Args,
  BaseCommandWithVerbosity,
  command,
  CommandArgs,
  CommandFlags,
  extendsFlagsInput,
  Flags,
  runCli,
} from "../lib/oclif";
export { allOclifCommands };

const ENV_PREFIX = "QCFG_SHCOMP_";

const BANNER = "Auto-generated by shcomp";

const PARSERS = ["oclif", "yargs"] as const;

type Parser = ElementType<typeof PARSERS>;

const logger = RootLogger.get();

abstract class RootCommand extends BaseCommandWithVerbosity {
  static override baseFlags = {
    ...super.baseFlags,
    db: Flags.file({
      summary: "Path to database file",
      env: ENV_PREFIX + "DB",
    }),
    save: Flags.boolean({
      char: "s",
      summary: "Save generation parameters to database",
    }),
    zsh_dir: Flags.directory({
      summary: "Path to directory with zsh completion scripts",
      aliases: ["zsh-dir"],
      helpLabel: "--zsh-dir",
      env: ENV_PREFIX + "ZSH_DIR",
      default: "/usr/local/share/zsh/site-functions",
    }),
  } as const;

  protected declare flags: CommandFlags<typeof RootCommand>;

  protected override logHandlerOptions: Omit<LogHandlerOptions, "level"> = {
    formatter: {
      template: LogFormat.INSTANCE_AND_MSG,
    },
  };

  async readDb(options: { onlyIfSave?: boolean; requireExisting?: boolean }): Promise<Database> {
    if (!this.flags.save && options.onlyIfSave) return {};
    const dbPath = this.flags.db;
    if (!dbPath) {
      if (options.requireExisting) throw new Error("Database file not specified");
      logger.debug("Database file not specified");
      return {};
    }
    if (!(await pathExists(dbPath))) {
      if (options.requireExisting) throw new Error("Database file does not exist");
      logger.debug(`Database file ${dbPath} does not exist`);
      return {};
    }

    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
    const file = JSON.parse(await readFile(dbPath, "utf-8"));
    return dbSchema.parse(file);
  }

  async writeDb(db: Database) {
    if (!this.flags.save) return;
    assertNotNull(this.flags.db, "Database file not specified");
    await writeFile(this.flags.db, JSON.stringify(db, null, 2));
  }
}

@command("list")
export class ListCommand extends RootCommand {
  static override summary = "List all commands present in database";
  override async run() {
    const database = await this.readDb({ requireExisting: true });
    const commands = Object.keys(database);
    console.log(commands.join("\n"));
  }
}

@command("gen")
class GenCommand extends RootCommand {
  static override summary = "Generate completion scripts";
  static override description = dedent`
    Auto-detects command line library used by command executable/script
    and generates completion script for it.
    `;

  static override args = {
    command: Args.string({
      description: "Command to generate completion script for",
      required: true,
    }),
  };

  static override flags = {
    force: Flags.boolean({
      char: "f",
      summary: "Force generation of completion script",
      description: dedent`
        This will generate script even if current script was not generated by this tool.
        `,
    }),
  };

  protected declare flags: CommandFlags<typeof GenCommand>;
  protected declare args: CommandArgs<typeof GenCommand>;

  protected readDbIfSave = false;

  override async run() {
    const database = await this.readDb({ onlyIfSave: this.readDbIfSave });
    const generator = new Generator(this.args.command, {
      ...this.flags,
      database,
      showInstruction: true,
    });
    await this.runGenerator(generator);
    await this.writeDb(database);
  }

  protected async runGenerator(generator: Generator) {
    await generator.generate();
  }
}

class SpecificGenCommand extends GenCommand {
  protected override readDbIfSave = true;
}

@command("oclif", { parent: GenCommand })
export class OclifCommand extends SpecificGenCommand {
  static override summary = "Generate completion script for JS/TS CLI using Oclif.";

  protected declare flags: CommandFlags<typeof OclifCommand>;

  protected override async runGenerator(generator: Generator): Promise<void> {
    await generator.generateYargs();
  }
}

@command("yargs", { parent: GenCommand })
export class YargsCommand extends SpecificGenCommand {
  static override summary = "Generate completion script for JS/TS CLI using Yargs.";

  protected override async runGenerator(generator: Generator): Promise<void> {
    await generator.generateYargs();
  }
}

@command("all")
export class AllCommand extends RootCommand {
  static override flags = extendsFlagsInput({
    jobs: Flags.integer({
      char: "j",
      min: 0,
      summary: "Number of parallel jobs to run (0 - no limit)",
      default: 10,
    }),
  });

  override async run() {
    const database = await this.readDb({ requireExisting: true });
    const commands = Object.keys(database);
    if (commands.length === 0) {
      logger.warn("Database is empty");
      return;
    }

    await mapAsync(commands, async (command) => {
      const generator = new Generator(command, {
        ...this.flags,
        database,
        logger: new InstanceLogger(command, { parent: logger }),
      });
      await generator.generate();
    });

    await this.writeDb(database);
  }
}

class Generator {
  protected scriptName: string;
  protected cmdPath!: string;
  protected dstPath: string;
  protected logger: Logger;

  constructor(
    protected readonly command: string,
    protected readonly options: {
      logger?: Logger;
      zsh_dir: string;
      force?: boolean;
      database?: Database;
      save?: boolean;
      /** Show instructions to reload completion */
      showInstruction?: boolean;
    },
  ) {
    // perhaps some more escaping is needed
    this.scriptName = "_" + command;
    this.dstPath = pathJoin(this.options.zsh_dir, this.scriptName);
    this.logger = this.options.logger ?? logger;
  }

  private getParserFromDb() {
    if (this.options.database?.[this.command]) {
      const config = this.options.database[this.command];
      const parser = config.parser;
      if (parser) this.logger.debug("Using parser from db: " + parser);
      return parser;
    }
    return undefined;
  }

  private async detectParser(): Promise<Parser | undefined> {
    await this.searchInPath();
    const cmdContent = await readFile(this.cmdPath, "utf-8");
    let parser: Parser | undefined = undefined;
    if (/oclif/i.test(cmdContent)) parser = "oclif";
    if (/yargs/i.test(cmdContent)) parser = "yargs";
    if (parser) this.logger.debug("Detected parser: " + parser);
    return parser;
  }

  async searchInPath() {
    if (this.cmdPath) return;
    this.cmdPath = await which(this.command);
    this.logger.debug(`Found command "${this.command}" at ${this.cmdPath}`);
  }

  async generate() {
    const parser = this.getParserFromDb() ?? (await this.detectParser());
    if (!parser) {
      throw new Error(this.command + ": could not detect parser");
    }

    switch (parser) {
      case "oclif":
        return this.generateOclif();
      case "yargs":
        return this.generateYargs();
    }
    throw new Error("should not happen");
  }

  saveConfig(config: CmdConfig) {
    if (!(this.options.save && this.options.database)) return;
    const oldConfig = this.options.database[this.command] ?? {};
    const newConfig = {
      ...oldConfig,
      ...config,
    };
    if (jsonDeepEqual(oldConfig, newConfig)) {
      this.logger.debug(`Config for ${this.command} is up to date`);
      return;
    }
    this.options.database[this.command] = newConfig;
    this.logger.info(`Updated config for ${this.command}`);
  }

  async generateOclif() {
    await this.searchInPath();
    const setup = (
      await run([this.command, "autocomplete", "script", "zsh"], { check: true, stdout: "pipe" })
    ).stdout!;
    // output will look like:
    // SHCOMP_GEN_AC_ZSH_SETUP_PATH=/Users/sergei/Library/Caches/shcomp-gen/autocomplete/zsh_setup && test -f $SHCOMP_GEN_AC_ZSH_SETUP_PATH && source $SHCOMP_GEN_AC_ZSH_SETUP_PATH; # shcomp-gen autocomplete scriptetup
    const match = /[A-Z_]+ZSH_SETUP_PATH=(\/.*\/autocomplete\/zsh_setup) &&/.exec(setup);
    assertNotNull(match, "Could not find autocomplete script path in output: " + setup);

    // this actually creates the script
    await run([this.command, "autocomplete", "create"], { check: true });

    const srcPath = pathJoin(dirname(match[1]), "functions", "zsh", this.scriptName);
    this.logger.debug(`Completion script should have been written to ${srcPath}`);
    const generatedScript = await readFile(srcPath, "utf-8");

    const updated = await this.writeGenerated(generatedScript);
    this.saveConfig({ parser: "oclif" });
    if (updated) this.showInstruction(this.scriptName);
  }

  /**
   * Must be executed before process exit
   */
  showInstruction(completionFunc: string) {
    if (this.options.showInstruction) {
      console.log(dedent`
      Now run these commands to reload completion function:

        unfunction ${completionFunc}
        source ${this.dstPath}
      `);
    }
  }

  /** Returns true if script was written to file */
  async writeGenerated(generatedScript: string) {
    let oldScript = "";
    if (await pathExists(this.dstPath)) {
      oldScript = await readFile(this.dstPath, "utf-8");
      if (!oldScript.includes(BANNER)) {
        if (this.options.force)
          this.logger.warn("Old script was generated by different tool, but --force was set");
        else throw new Error("Old script was generated by different tool");
      }
    }

    const newScript = generatedScript + `\n\n# ${BANNER}\n`;

    if (newScript === oldScript) {
      this.logger.debug("Completion script is up to date");
      if (!this.options.force) return false;
    }
    await writeFile(this.dstPath, newScript);
    this.logger.debug("Written script to " + this.dstPath);
    this.logger.info(`Updated completion script for ${this.command}`);
    return true;
  }

  async generateYargs() {
    await this.searchInPath();

    const generatedScript = completionZshTemplate
      .replaceAll("{{app_name}}", this.command)
      .replaceAll("{{app_path}}", this.cmdPath);

    const updated = await this.writeGenerated(generatedScript);
    this.saveConfig({ parser: "yargs" });
    if (updated) this.showInstruction(`_${this.command}_yargs_completions`);
  }
}

const cmdConfigSchema = zod.object({
  parser: zod.enum(PARSERS).optional(),
});

const dbSchema = zod.record(cmdConfigSchema);

type Database = zod.infer<typeof dbSchema>;
type CmdConfig = zod.infer<typeof cmdConfigSchema>;

// copied from https://github.com/wkunert/yargs/blob/zsh-completion-fallback/lib/completion-templates.ts
const completionZshTemplate = `#compdef {{app_name}}
###-begin-{{app_name}}-completions-###
#
# yargs command completion script
#
# Installation: {{app_path}} {{completion_command}} >> ~/.zshrc
#    or {{app_path}} {{completion_command}} >> ~/.zprofile on OSX.
#
_{{app_name}}_yargs_completions()
{
  local reply
  local si=$IFS
  IFS=$'\n' reply=($(COMP_CWORD="$((CURRENT-1))" COMP_LINE="$BUFFER" COMP_POINT="$CURSOR" {{app_path}} --get-yargs-completions "\${words[@]}"))
  IFS=$si
  if [[ \${#reply} -gt 0 ]]; then
    _describe 'values' reply
  else
    _default
  fi
}
compdef _{{app_name}}_yargs_completions {{app_name}}
###-end-{{app_name}}-completions-###
`;

void runCli(__filename, __dirname, {
  defaultCommand: "list",
  description: dedent`
    Generate completion scripts for (currently only) z-shell.

    Can be run in automated mode to update completion scripts for commands that changed.
    `,
});
